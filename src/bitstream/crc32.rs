/// Lookup table for a CRC32 in the normal form with the polynomial 0x04C11DB7.
const CRC32_LOOKUP_ARRAY: [u32; 256] = crc32_table();

#[allow(clippy::as_conversions)]
const fn crc32_table() -> [u32; 256] {
    let mut table: [u32; 256] = [0; 256];
    let mut byte_index: usize = 0;
    while byte_index < 256 {
        let mut crc: u32 = (byte_index as u32) << 24;

        let mut bit = 0;
        while bit < 8 {
            if (crc & (1 << 31)) != 0 {
                crc = (crc << 1) ^ 0x04C11DB7
            } else {
                crc <<= 1
            }
            bit += 1;
        }
        table[byte_index] = crc;
        byte_index += 1;
    }
    table
}

/// CRC32 hash function. Direct algorithm, initial val and final XOR = 0, generator polynomial=0x04c11db7.
#[allow(clippy::as_conversions)]
pub(crate) fn crc32_update(current_crc: u32, data: &[u8]) -> u32 {
    let mut crc: u32 = current_crc;
    for byte in data {
        crc = CRC32_LOOKUP_ARRAY[(u32::from(*byte) ^ (crc >> 24)) as usize] ^ (crc << 8);
    }
    crc
}

#[cfg(test)]
mod tests {
    #![allow(clippy::panic)]

    use super::*;

    #[test]
    fn test_crc32_ident_package() {
        let mut d: Vec<u8> = vec![
            0x4F, 0x67, 0x67, 0x53, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x4A, 0xC9, 0x09, 0xB6, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x20, 0x89, 0xF8, 0x01, 0x13,
            0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64, 0x01, 0x02, 0x38, 0x01, 0x80, 0xBB,
            0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let hash: [u8; 4] = [d[22], d[23], d[24], d[25]];
        d[22] = 0;
        d[23] = 0;
        d[24] = 0;
        d[25] = 0;

        let crc32 = crc32_update(0, &d);
        assert_eq!(u32::from_le_bytes(hash), crc32);
    }

    #[test]
    fn test_crc32_comment_package() {
        let mut d: Vec<u8> = vec![
            0x4F, 0x67, 0x67, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x4A, 0xC9, 0x09, 0xB6, 0x01, 0x00, 0x00, 0x00, 0xE2, 0x41, 0x7B, 0x3B, 0x01, 0xF5,
            0x4F, 0x70, 0x75, 0x73, 0x54, 0x61, 0x67, 0x73, 0x0D, 0x00, 0x00, 0x00, 0x6C, 0x69,
            0x62, 0x6F, 0x70, 0x75, 0x73, 0x20, 0x31, 0x2E, 0x33, 0x2E, 0x31, 0x09, 0x00, 0x00,
            0x00, 0x17, 0x00, 0x00, 0x00, 0x41, 0x52, 0x54, 0x49, 0x53, 0x54, 0x3D, 0x41, 0x4E,
            0x41, 0x4E, 0x54, 0x2D, 0x47, 0x41, 0x52, 0x44, 0x45, 0x20, 0x45, 0x59, 0x45, 0x53,
            0x12, 0x00, 0x00, 0x00, 0x54, 0x49, 0x54, 0x4C, 0x45, 0x3D, 0x74, 0x68, 0x65, 0x6D,
            0x65, 0x20, 0x6F, 0x66, 0x20, 0x53, 0x53, 0x53, 0x2B, 0x00, 0x00, 0x00, 0x41, 0x4C,
            0x42, 0x55, 0x4D, 0x3D, 0x41, 0x6E, 0x67, 0x65, 0x6C, 0x20, 0x42, 0x65, 0x61, 0x74,
            0x73, 0x21, 0x20, 0x4F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x53, 0x6F,
            0x75, 0x6E, 0x64, 0x74, 0x72, 0x61, 0x63, 0x6B, 0x20, 0x43, 0x44, 0x30, 0x31, 0x09,
            0x00, 0x00, 0x00, 0x44, 0x41, 0x54, 0x45, 0x3D, 0x32, 0x30, 0x31, 0x30, 0x0B, 0x00,
            0x00, 0x00, 0x47, 0x45, 0x4E, 0x52, 0x45, 0x3D, 0x41, 0x6E, 0x69, 0x6D, 0x65, 0x0E,
            0x00, 0x00, 0x00, 0x54, 0x52, 0x41, 0x43, 0x4B, 0x4E, 0x55, 0x4D, 0x42, 0x45, 0x52,
            0x3D, 0x30, 0x32, 0x0D, 0x00, 0x00, 0x00, 0x54, 0x52, 0x41, 0x43, 0x4B, 0x54, 0x4F,
            0x54, 0x41, 0x4C, 0x3D, 0x32, 0x37, 0x1C, 0x00, 0x00, 0x00, 0x43, 0x4F, 0x4D, 0x4D,
            0x45, 0x4E, 0x54, 0x3D, 0x23, 0x43, 0x48, 0x41, 0x4F, 0x53, 0x40, 0x49, 0x52, 0x43,
            0x2E, 0x52, 0x49, 0x5A, 0x4F, 0x4E, 0x2E, 0x4E, 0x45, 0x54, 0x15, 0x00, 0x00, 0x00,
            0x45, 0x4E, 0x43, 0x4F, 0x44, 0x45, 0x52, 0x3D, 0x66, 0x72, 0x65, 0x3A, 0x61, 0x63,
            0x20, 0x76, 0x31, 0x2E, 0x31, 0x2E, 0x34,
        ];

        let hash: [u8; 4] = [d[22], d[23], d[24], d[25]];
        d[22] = 0;
        d[23] = 0;
        d[24] = 0;
        d[25] = 0;

        let crc32 = crc32_update(0, &d);
        assert_eq!(u32::from_le_bytes(hash), crc32);
    }
}
